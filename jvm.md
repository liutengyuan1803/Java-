一:JVM 运行区域划分：  
Java虚拟机在执行Java程序时，会把它所管理的内存划分为若干个不同的数据区域，这些区域有不同的用途，创建和销毁的时间，根据是否线程共享粗略的划分如下：  
jdk1.8:  
 ![image](https://github.com/liutengyuan1803/lean_repo/blob/master/images/2.jpg)  
线程私有：    
1.Java虚拟机栈：Java虚拟机栈是线程私有的，它的生命周期与线程相同，它描述的是Java方法执行的内存模型：每个方法在执行时，都会创建一个栈帧,用于存储局部变量表,操作数栈，动态链接，方法出口信息，每个方法从调用到执行完成，就对应着栈帧从Java虚拟机栈中的入栈和出栈操作  
  a、局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。  
  b、返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。  
  c、操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意    Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。  
  d、动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。  
  2.本地方法栈(JNI) java虚拟机调用本地方法的入口。  
  3.程序计数器：记录字节码执行的行号，在多线程下记录代码执行的位置。  
共享区域：  
  4、堆（Heap）：Java对象存储的地方  
 （1）Java堆是虚拟机管理的内存中最大的一块  
 （2）Java堆是所有线程共享的区域  
 （3）在虚拟机启动时创建  
 （4）此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组  
 （5）Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”   
  5.元空间 元空间包含jdk之前版本的方法区和运行时常量池
    方法区：方法区中存储有类的元数据信息，常量、静态变量、即时编译后的代码等数据  
    运行时常量池：  
    A、是方法区的一部分  
    B、存放编译期生成的各种字面量和符号引用  
    C、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，
存放到方法区的运行时常量池中。  
  6.直接内存：  
  jdk1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。（零拷贝 DirectByteBuffer）  
二、内存分配  
这里暂且先讲对象在java堆中是如何分配、布局、访问以及内存分配的原则。  
1、对象的创建  
（1）查看在常量池中是否有对应的符号引用。【在方法区中进行】  
（2）查看此类是否被加载、解析和初始化过。【在方法区中进行】  
（3）领取新生对象的内存。有两种方式：指针碰撞和空闲列表。【在堆中进行】  
（4）将分配到的内存空间初始化为零。  
（5）对对象进行必要的设置，比如其实哪个类的实例，对象的哈希码之类的。这些信息存放在对象的对象头中。  
（6）如果java代码对对象进行了赋值，则会走到第六步，执行<init>方法。此方法的作用就是对对象进行初始化。  
2、对象的内存布局  
对象在内存中的存储布局分为三个部分：对象头+实例数据+对其补充  
对象头  
对象头里面有两部分信息：  
（1）运行时数据，包括哈希码、GC分代年龄、锁状态标志灯。  
（2）类型指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  
实例数据  
实例数据中存放的是代码中定义的各种类型的字段内容。  
对其填充  
对齐填充起的是占位符的作用，不是必然存在的，其只要保证对象的大小是8字节的整数倍即可。  
3、对象的访问定位  
建立完对象后，我们就可以使用对象了。通过句柄和直接指针两种方式。  
4、对象的分配
  a、对象有限在Edon区进行分配；
  b、大对象可直接进入老年代；
  c、大年龄的对象进入老年代，新生代没发生一次minorGC对象的年龄则回加1，JVM会给对象增加一个年龄（age）的计数器，对象每“熬过”一次GC，年龄就要+1，待对象到达设置的阈值（默认为15岁）就会被移移动到老年代，可通过-XX:MaxTenuringThreshold调整这个阈值。  
 一次Minor GC后，对象年龄就会+1，达到阈值的对象就移动到老年代，其他存活下来的对象会继续保留在新生代中。  
  d、根据年龄动态判断，根据对象年龄有另外一个策略也会让对象进入老年代，不用等待15次GC之后进入老年代，他的大致规则就是，假如当前放对象的Survivor，一批对象的总大小大于这块Survivor内存的50%，那么大于这批对象年龄的对象，就可以直接进入老年代了。  

三、垃圾回收算法  
标记清除 标记整理 复制清除  分代回收
 一、 判断对象是否要回收的方法：可达性分析法  
1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）  
2、 以下对象会被认为是root对象：  
（1） 虚拟机栈（栈帧中本地变量表）中引用的对象  
（2） 方法区中静态属性引用的对象  
（3） 方法区中常量引用的对象  
（4） 本地方法栈中Native方法引用的对象  
3、 对象被判定可被回收，需要经历两个阶段：  
（1） 第一个阶段是可达性分析，分析该对象是否可达  
（2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）  
4、 方法区中的垃圾回收：  
（1） 常量池中一些常量、符号引用没有被引用，则会被清理出常量池  
（2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：  
A、 该类的所有实例被回收  
B、 加载该类的ClassLoader被回收  
C、 该类的Class对象没有被引用  
5、 finalize():  
（1） GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。  
（2） 可以在该方法里面，指定一些对象在释放前必须执行的操作。  

二、 发现虚拟机频繁full GC时应该怎么办：  
（full GC指的是清理整个堆空间，包括年轻代和永久代）  
（1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id  
（2） 如果是System.gc()，则看下代码哪里调用了这个方法  
（3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令  
（4） 如果是GC locker，可能是程序依赖的JNI库的原因  

三、常见的垃圾回收算法：  
1、Mark-Sweep（标记-清除算法）：  
（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。  
（2）优缺点：实现简单，容易产生内存碎片  
2、Copying（复制清除算法）：  
（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。  
（2）优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。  
3、Mark-Compact（标记-整理算法）：  
（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。  
（2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下  

4、分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：  
思想：把堆分成新生代和老年代。（永久代指的是方法区）  
（1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。  
（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。  
（3） 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量  
5、GC使用时对程序的影响？  
垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间  
6、几种不同的垃圾回收类型：  
（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。  
   A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC  
   B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被掉。  （2）Major GC：清理整个老年代，当eden区内存不足时触发。  
（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发  
参考资料：https://mp.weixin.qq.com/s/DCBTJtsWctefBZZw-EK-kw  
参考资料：https://mp.weixin.qq.com/s/W8xOsM0vPpAs2zsA6kuS9g  
  
  
